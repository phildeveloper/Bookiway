@page "/"
@page "/translation"
@layout EmptyLayout
@rendermode InteractiveServer

@using System.Globalization
@using System.IO
@using System.Linq
@using BookiwayApp.Services

@inject PdfDecomposerService PdfDecomposer
@inject IJSRuntime JS
@inject GeminiTranslationService Translator

<PageTitle>Bookiway</PageTitle>

<div class="translation-shell">
    <div class="hero">
        <span class="hero-eyebrow">Интерактивная платформа</span>
        <span class="hero-brand">Bookiway</span>
        <p class="hero-subtitle">
            Умный инструмент для перевода PDF в HTML.
            Все настройки сохраняются в cookies, чтобы вы могли продолжить работу с последнего шага.
        </p>
    </div>


    <div class="workflow-grid">
        <section class="panel panel-upload">
            <header class="panel-header">
                <p class="panel-step">Шаг 1</p>
                <div>
                    <h2>Выберите PDF</h2>
                    <p>Загрузите нужный PDF-файл и выберите папку, куда будут сохранены изображения страниц.</p>
                </div>
            </header>

            <div class="panel-block">
                <p class="field-label">PDF-файл</p>
                <label class="file-picker" for="pdfUpload">
                    <span class="file-picker-icon" aria-hidden="true">PDF</span>
                    <span class="file-picker-text">@(_fileName is null ? "Выберите PDF" : _fileName)</span>
                    <InputFile id="pdfUpload" OnChange="HandleFileSelected" accept="application/pdf" />
                </label>
                <p class="muted-text">До 10 МБ. Можно использовать последнюю выбранную папку из cookies.</p>
                @if (!string.IsNullOrWhiteSpace(_lastPdfName) && _selectedFile is null)
                {
                    <p class="muted-link" aria-live="polite">Последний файл: @_lastPdfName</p>
                }
            </div>

            <div class="panel-block">
                <p class="field-label">Папка для изображений</p>
                <div class="input-row">
                    <span class="input-chip">@(!string.IsNullOrWhiteSpace(TrimmedOutputDirectory) ? TrimmedOutputDirectory : "Не выбрана")</span>
                    <button type="button" class="ghost-button" @onclick="() => OpenDirectoryPicker(DirectoryTarget.Images)" disabled="@_isProcessing">Выбрать</button>
                </div>
                <p class="muted-text">Изображения будут сохранены в формате page-XXXX.png. Путь запоминается в cookies.</p>
            </div>

            <div class="panel-block action-block">
                <div class="action-row">
                    <button class="primary-button" @onclick="StartDecompositionAsync" disabled="@IsDecomposeDisabled">
                        @if (_isProcessing)
                        {
                            <span class="spinner" aria-hidden="true"></span>
                        }
                        <span>@(_isProcessing ? "Разбиваю..." : "Разбить PDF")</span>
                    </button>
                    <span class="hint">После нажатия начнётся обработка файла и создание изображений страниц.</span>
                </div>

                @if (_isProcessing)
                {
                    <div class="progress" role="status" aria-live="polite">
                        <div class="progress-bar" style="width: @_progressPercent%;"></div>
                    </div>
                    <p class="progress-value">@_progressPercent%</p>
                }

                @if (!string.IsNullOrEmpty(_statusMessage))
                {
                    var statusClass = _isSuccess ? "status success" : "status error";
                    <p class="@statusClass">@_statusMessage</p>
                }
            </div>
        </section>


        <section class="panel panel-translate">
            <header class="panel-header">
                <p class="panel-step">Шаг 2</p>
                <div>
                    <h2>Перевод страниц</h2>
                    <p>Укажите диапазон страниц и папку для HTML. Сервис автоматически создаст переведённые версии страниц.</p>
                </div>
            </header>

            <div class="panel-block">
                <p class="field-label">Диапазон страниц</p>
                <div class="range-row">
                    <input type="number" min="1" max="@_totalPages" value="@_pageFrom" @oninput="OnPageFromChangedAsync" class="range-input" />
                    <span class="range-separator">–</span>
                    <input type="number" min="1" max="@_totalPages" value="@_pageTo" @oninput="OnPageToChangedAsync" class="range-input" />
                    <span class="range-total">@(_totalPages > 0 ? $"Всего: {_totalPages}" : "Пока нет страниц")</span>
                </div>
                @if (!string.IsNullOrEmpty(_pageRangeError))
                {
                    <p class="status error">@_pageRangeError</p>
                }
            </div>

            <div class="panel-block">
                <p class="field-label">Папка для HTML</p>
                <div class="input-row">
                    <span class="input-chip">@(!string.IsNullOrWhiteSpace(TrimmedTranslationDirectory) ? TrimmedTranslationDirectory : "Не выбрана")</span>
                    <button type="button" class="ghost-button" @onclick="() => OpenDirectoryPicker(DirectoryTarget.Html)" disabled="@_isTranslating">Выбрать</button>
                </div>
                <p class="muted-text">Укажите папку, куда будут сохранены переведённые HTML-файлы. Путь запоминается автоматически.</p>
            </div>

            <div class="panel-block action-block">
                <div class="action-row">
                    <button class="primary-button" @onclick="StartTranslationAsync" disabled="@(!_isPageRangeValid || _totalPages == 0 || string.IsNullOrWhiteSpace(TrimmedTranslationDirectory) || _isTranslating)">
                        @if (_isTranslating)
                        {
                            <span class="spinner" aria-hidden="true"></span>
                        }
                        <span>@(_isTranslating ? "Перевожу..." : "Перевести через Gemini")</span>
                    </button>
                    <span class="hint">Во время перевода используется последняя обработка PDF.</span>
                </div>

                @if (_isTranslating)
                {
                    <div class="progress" role="status" aria-live="polite">
                        <div class="progress-bar" style="width: @_translateProgress%;"></div>
                    </div>
                    <p class="progress-value">@_translateProgress%</p>
                }

                @if (!string.IsNullOrEmpty(_translateStatus))
                {
                    var tClass = _translateSuccess ? "status success" : "status error";
                    <p class="@tClass">@_translateStatus</p>
                }
            </div>
        </section>

    </div>
</div>
@if (_isDirectoryPickerOpen)
{
    <div class="directory-modal" role="dialog" aria-modal="true">
        <div class="directory-modal-content">
            <div class="directory-modal-header">
                <h3>Выбор папки</h3>
                <p class="directory-modal-path" title="@_directoryBrowserPath">@_directoryBrowserPath</p>
            </div>

            @if (!string.IsNullOrEmpty(_directoryBrowserError))
            {
                <p class="status error">@_directoryBrowserError</p>
            }

            <div class="directory-browser">
                <div class="directory-browser-actions">
                    <button type="button" class="ghost-button" @onclick="NavigateUp" disabled="@(!CanNavigateUp)">Назад</button>
                    <button type="button" class="ghost-button" @onclick="RefreshCurrentDirectory">Обновить</button>
                </div>

                <ul class="directory-list" role="listbox">
                    @if (_directoryEntries.Count == 0)
                    {
                        <li class="directory-empty">Папок не найдено</li>
                    }
                    else
                    {
                        @foreach (var entry in _directoryEntries)
                        {
                            <li>
                                <button type="button" class="directory-item" @onclick="() => NavigateToDirectory(entry.FullPath)">
                                    <span class="directory-item-icon" aria-hidden="true"></span>
                                    <span>@entry.Name</span>
                                </button>
                            </li>
                        }
                    }
                </ul>
            </div>

            <div class="directory-modal-footer">
                <button type="button" class="primary-button" @onclick="ConfirmDirectorySelectionAsync">Выбрать папку</button>
                <button type="button" class="ghost-button" @onclick="CloseDirectoryPicker">Отмена</button>
            </div>
        </div>
    </div>
}


@code {
    private const long MaxFileSize = 10 * 1024 * 1024;
    private const string PdfNameCookie = "bw_last_pdf_name";
    private const string ImagesDirCookie = "bw_last_output_dir";
    private const string HtmlDirCookie = "bw_last_html_dir";
    private const string PageFromCookie = "bw_last_page_from";
    private const string PageToCookie = "bw_last_page_to";
    private const string PdfCacheCookie = "bw_last_pdf_cache";
    private static readonly string PdfCacheDirectory = Path.Combine(AppContext.BaseDirectory, "PdfCache");

    private IBrowserFile? _selectedFile;
    private string? _fileName;
    private string _outputDirectory = string.Empty;
    private string _translationOutputDirectory = string.Empty;
    private string? _cachedPdfPath;
    private string? _lastPdfName;
    private int _totalPages;
    private int _pageFrom = 1;
    private int _pageTo = 1;
    private bool _isPageRangeValid = true;
    private string? _pageRangeError;
    private bool _isProcessing;
    private bool _isTranslating;
    private int _translateProgress;
    private string? _translateStatus;
    private bool _translateSuccess;
    private int _progressPercent;
    private string? _statusMessage;
    private bool _isSuccess;
    private bool _isDirectoryPickerOpen;
    private string _directoryBrowserPath = string.Empty;
    private List<DirectoryEntry> _directoryEntries = new();
    private string? _directoryBrowserError;
    private DirectoryTarget _directoryTarget = DirectoryTarget.Images;

    private bool HasCachedPdf => _selectedFile is not null || !string.IsNullOrWhiteSpace(_cachedPdfPath);
    private bool IsDecomposeDisabled => !HasCachedPdf || string.IsNullOrWhiteSpace(TrimmedOutputDirectory) || _isProcessing;
    private bool CanNavigateUp => TryGetParentDirectory(_directoryBrowserPath) is not null;
    private string TrimmedOutputDirectory => _outputDirectory?.Trim() ?? string.Empty;
    private string TrimmedTranslationDirectory => _translationOutputDirectory?.Trim() ?? string.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        Directory.CreateDirectory(PdfCacheDirectory);

        _lastPdfName = await GetCookieAsync(PdfNameCookie);
        var savedImagesDir = await GetCookieAsync(ImagesDirCookie);
        if (!string.IsNullOrWhiteSpace(savedImagesDir))
        {
            _outputDirectory = savedImagesDir!;
        }

        var savedHtmlDir = await GetCookieAsync(HtmlDirCookie);
        if (!string.IsNullOrWhiteSpace(savedHtmlDir))
        {
            _translationOutputDirectory = savedHtmlDir!;
        }

        var cachedPdfId = await GetCookieAsync(PdfCacheCookie);
        if (!string.IsNullOrWhiteSpace(cachedPdfId))
        {
            var potentialPath = Path.Combine(PdfCacheDirectory, cachedPdfId!);
            var exists = File.Exists(potentialPath);
            _cachedPdfPath = potentialPath;

            if (exists && !string.IsNullOrWhiteSpace(_lastPdfName))
            {
                _fileName = _lastPdfName;
            }
            else if (!exists && !string.IsNullOrWhiteSpace(_lastPdfName))
            {
                _statusMessage = $"Файл {_lastPdfName} не найден в кэше. Возможно, он был удалён или перемещён.";
                _isSuccess = false;
            }
        }


        var savedFrom = await GetCookieAsync(PageFromCookie);
        if (int.TryParse(savedFrom, NumberStyles.Integer, CultureInfo.InvariantCulture, out var fromValue) && fromValue > 0)
        {
            _pageFrom = fromValue;
        }

        var savedTo = await GetCookieAsync(PageToCookie);
        if (int.TryParse(savedTo, NumberStyles.Integer, CultureInfo.InvariantCulture, out var toValue) && toValue > 0)
        {
            _pageTo = toValue;
        }

        if (!string.IsNullOrWhiteSpace(TrimmedOutputDirectory))
        {
            await RecalculatePagesFromImagesFolderAsync();
        }
        else
        {
            ValidatePageRange();
            await PersistPageRangeAsync();
        }

        StateHasChanged();
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        _selectedFile = e.File;
        _fileName = e.File?.Name;
        _statusMessage = null;

        if (!string.IsNullOrWhiteSpace(_fileName))
        {
            await SaveCookieAsync(PdfNameCookie, _fileName);
            _lastPdfName = _fileName;
        }

        try
        {
            await CacheSelectedFileAsync();
        }
        catch (Exception ex)
        {
            _cachedPdfPath = null;
            _statusMessage = $"Ошибка при сохранении PDF-файла: {ex.Message}";
        }
    }


    private enum DirectoryTarget
    {
        Images,
        Html
    }

    private async Task CacheSelectedFileAsync()
    {
        if (_selectedFile is null)
        {
            return;
        }

        Directory.CreateDirectory(PdfCacheDirectory);

        if (!string.IsNullOrWhiteSpace(_cachedPdfPath) && File.Exists(_cachedPdfPath))
        {
            TryDeleteFile(_cachedPdfPath);
        }

        var extension = Path.GetExtension(_selectedFile.Name);
        var safeExtension = string.IsNullOrWhiteSpace(extension) ? ".pdf" : extension;
        var cacheFileName = $"{Guid.NewGuid():N}{safeExtension}";
        var cacheFullPath = Path.Combine(PdfCacheDirectory, cacheFileName);

        await using var targetStream = File.Create(cacheFullPath);
        await using var sourceStream = _selectedFile.OpenReadStream(MaxFileSize);
        await sourceStream.CopyToAsync(targetStream);

        _cachedPdfPath = cacheFullPath;
        await SaveCookieAsync(PdfCacheCookie, cacheFileName);

        _selectedFile = null;
    }

    private async Task<Stream?> GetPdfStreamAsync()
    {
        if (!string.IsNullOrWhiteSpace(_cachedPdfPath) && File.Exists(_cachedPdfPath))
        {
            return File.OpenRead(_cachedPdfPath);
        }

        if (_selectedFile is not null)
        {
            await CacheSelectedFileAsync();
            if (!string.IsNullOrWhiteSpace(_cachedPdfPath) && File.Exists(_cachedPdfPath))
            {
                return File.OpenRead(_cachedPdfPath);
            }
        }

        return null;
    }

    private void OpenDirectoryPicker(DirectoryTarget target)
    {
        _directoryTarget = target;
        var current = target == DirectoryTarget.Images ? TrimmedOutputDirectory : TrimmedTranslationDirectory;
        var initialPath = string.IsNullOrWhiteSpace(current) ? GetDefaultDirectory() : current;

        _directoryBrowserError = null;

        if (!TryLoadDirectory(initialPath))
        {
            TryLoadDirectory(GetDefaultDirectory());
        }

        _isDirectoryPickerOpen = true;
    }

    private void CloseDirectoryPicker()
    {
        _isDirectoryPickerOpen = false;
    }

    private async Task ConfirmDirectorySelectionAsync()
    {
        if (!string.IsNullOrWhiteSpace(_directoryBrowserPath))
        {
            if (_directoryTarget == DirectoryTarget.Images)
            {
                _outputDirectory = _directoryBrowserPath;
                await SaveCookieAsync(ImagesDirCookie, _outputDirectory);
                await RecalculatePagesFromImagesFolderAsync();
            }
            else
            {
                _translationOutputDirectory = _directoryBrowserPath;
                await SaveCookieAsync(HtmlDirCookie, _translationOutputDirectory);
            }
        }

        _isDirectoryPickerOpen = false;
    }

    private void NavigateToDirectory(string path)
    {
        TryLoadDirectory(path);
    }

    private void NavigateUp()
    {
        var parent = TryGetParentDirectory(_directoryBrowserPath);
        if (parent is not null)
        {
            TryLoadDirectory(parent.FullName);
        }
    }

    private void RefreshCurrentDirectory()
    {
        TryLoadDirectory(_directoryBrowserPath);
    }

    private async Task StartDecompositionAsync()
    {
        if (!HasCachedPdf)
        {
            _statusMessage = "Не выбран PDF-файл для обработки.";
            _isSuccess = false;
            return;
        }

        if (string.IsNullOrWhiteSpace(TrimmedOutputDirectory))
        {
            _statusMessage = "Не указана папка для сохранения изображений. Пожалуйста, выберите директорию.";
            _isSuccess = false;
            return;
        }

        _isProcessing = true;
        _statusMessage = null;
        _isSuccess = false;
        _progressPercent = 0;
        _totalPages = 0;

        var progress = new Progress<double>(value =>
        {
            _progressPercent = (int)Math.Clamp(Math.Round(value * 100, MidpointRounding.AwayFromZero), 0, 100);
            InvokeAsync(StateHasChanged);
        });

        try
        {
            await using var stream = await GetPdfStreamAsync();
            if (stream is null)
            {
                _statusMessage = "Не удалось открыть PDF-файл. Возможно, он повреждён или был удалён.";
                _isSuccess = false;
                return;
            }

            var outputDirectory = TrimmedOutputDirectory;
            var result = await PdfDecomposer.DecomposeAsync(stream, outputDirectory, progress);

            _isSuccess = true;
            _statusMessage = result.PageCount == 0
                ? "PDF не содержит страниц или не удалось извлечь изображения."
                : $"Успешно: извлечено {result.PageCount} страниц в папку '{outputDirectory}'.";

            _progressPercent = 100;
            _totalPages = result.PageCount;
            _pageFrom = _totalPages > 0 ? 1 : 0;
            _pageTo = _totalPages;

            ValidatePageRange();
            await PersistPageRangeAsync();
        }
        catch (Exception ex)
        {
            _isSuccess = false;
            _statusMessage = $"Ошибка при разборе PDF-файла: {ex.Message}";
        }
        finally
        {
            _isProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }


    private async Task OnPageFromChangedAsync(ChangeEventArgs e)
    {
        if (int.TryParse(Convert.ToString(e.Value, CultureInfo.InvariantCulture), NumberStyles.Integer, CultureInfo.InvariantCulture, out var value))
        {
            _pageFrom = value;
            ValidatePageRange();
            await PersistPageRangeAsync();
        }
    }

    private async Task OnPageToChangedAsync(ChangeEventArgs e)
    {
        if (int.TryParse(Convert.ToString(e.Value, CultureInfo.InvariantCulture), NumberStyles.Integer, CultureInfo.InvariantCulture, out var value))
        {
            _pageTo = value;
            ValidatePageRange();
            await PersistPageRangeAsync();
        }
    }

    private void ValidatePageRange()
    {
        _isPageRangeValid =
            _totalPages > 0 &&
            _pageFrom >= 1 &&
            _pageTo >= 1 &&
            _pageFrom <= _pageTo &&
            _pageTo <= _totalPages;

        _pageRangeError = _isPageRangeValid
            ? null
            : $"Некорректный диапазон страниц. Допустимо от 1 до {_totalPages}. Убедитесь, что «с» ≤ «по» и обе границы не выходят за пределы числа страниц.";
    }


    private async Task RecalculatePagesFromImagesFolderAsync()
    {
        try
        {
            if (!string.IsNullOrWhiteSpace(TrimmedOutputDirectory) && Directory.Exists(TrimmedOutputDirectory))
            {
                var files = Directory.GetFiles(TrimmedOutputDirectory, "page-*.png");
                _totalPages = files.Length;
                _pageFrom = _totalPages > 0 ? Math.Clamp(_pageFrom <= 0 ? 1 : _pageFrom, 1, _totalPages) : 0;
                _pageTo = _totalPages > 0 ? Math.Clamp(_pageTo <= 0 ? _totalPages : _pageTo, 1, _totalPages) : 0;
                ValidatePageRange();
            }
            else
            {
                _totalPages = 0;
                ValidatePageRange();
            }
        }
        catch
        {
            _totalPages = 0;
            ValidatePageRange();
        }

        await PersistPageRangeAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task StartTranslationAsync()
    {
        if (!_isPageRangeValid || _totalPages == 0)
        {
            _translateSuccess = false;
            _translateStatus = "Некорректный диапазон страниц или нет страниц для перевода.";
            return;
        }

        var sourceDir = TrimmedOutputDirectory;
        var destinationDir = TrimmedTranslationDirectory;

        if (string.IsNullOrWhiteSpace(sourceDir) || string.IsNullOrWhiteSpace(destinationDir))
        {
            _translateSuccess = false;
            _translateStatus = "Укажите папку с изображениями (PNG) и папку для вывода HTML-файлов.";
            return;
        }

        _isTranslating = true;
        _translateProgress = 0;
        _translateStatus = null;
        _translateSuccess = false;

        var progress = new Progress<double>(value =>
        {
            _translateProgress = (int)Math.Clamp(Math.Round(value * 100, MidpointRounding.AwayFromZero), 0, 100);
            InvokeAsync(StateHasChanged);
        });

        try
        {
            var count = await Translator.TranslateRangeAsync(sourceDir, _pageFrom, _pageTo, destinationDir, progress);

            _translateSuccess = count > 0;
            _translateStatus = count == 0
                ? "Не удалось создать ни одного HTML-файла. Проверьте диапазон страниц и содержимое исходной папки."
                : $"Готово: создано {count} HTML-файлов в «{destinationDir}».";
        }
        catch (Exception ex)
        {
            _translateSuccess = false;
            _translateStatus = $"Ошибка во время перевода: {ex.Message}";
        }
        finally
        {
            _isTranslating = false;
            await InvokeAsync(StateHasChanged);
        }
    }


    private bool TryLoadDirectory(string directory)
    {
        try
        {
            var fullPath = Path.GetFullPath(directory);
            if (!Directory.Exists(fullPath))
            {
                _directoryBrowserError = $"Папка '{directory}' не найдена.";
                _directoryEntries = new List<DirectoryEntry>();
                return false;
            }

            _directoryBrowserPath = fullPath;
            _directoryEntries = Directory.GetDirectories(fullPath)
                .OrderBy(dir => dir, StringComparer.OrdinalIgnoreCase)
                .Select(dir => new DirectoryEntry(GetDirectoryDisplayName(dir), dir))
                .ToList();

            _directoryBrowserError = null;
            return true;
        }
        catch (Exception ex)
        {
            _directoryBrowserError = $"Ошибка при открытии папки: {ex.Message}";
            _directoryEntries = new List<DirectoryEntry>();
            return false;
        }
    }


    private static string GetDirectoryDisplayName(string path)
    {
        var name = Path.GetFileName(path);
        if (string.IsNullOrEmpty(name))
        {
            name = new DirectoryInfo(path).Name;
        }

        return string.IsNullOrEmpty(name) ? path : name;
    }

    private static DirectoryInfo? TryGetParentDirectory(string? path)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return null;
        }

        try
        {
            return Directory.GetParent(path);
        }
        catch
        {
            return null;
        }
    }

    private static string GetDefaultDirectory()
    {
        var candidates = new[]
        {
            Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
            Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
            Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
            Environment.CurrentDirectory
        };

        foreach (var candidate in candidates)
        {
            if (!string.IsNullOrWhiteSpace(candidate) && Directory.Exists(candidate))
            {
                return candidate;
            }
        }

        return Environment.CurrentDirectory;
    }

    private static void TryDeleteFile(string path)
    {
        try
        {
            File.Delete(path);
        }
        catch
        {
        }
    }

    private async Task SaveCookieAsync(string key, string value)
    {
        await JS.InvokeAsync<bool>("cookies.set", key, value, 365);
    }

    private async Task<string?> GetCookieAsync(string key)
    {
        return await JS.InvokeAsync<string?>("cookies.get", key);
    }

    private async Task PersistPageRangeAsync()
    {
        if (_pageFrom > 0)
        {
            await SaveCookieAsync(PageFromCookie, _pageFrom.ToString(CultureInfo.InvariantCulture));
        }

        if (_pageTo > 0)
        {
            await SaveCookieAsync(PageToCookie, _pageTo.ToString(CultureInfo.InvariantCulture));
        }
    }

    private sealed record DirectoryEntry(string Name, string FullPath);
}