@page "/"
@page "/translation"
@layout EmptyLayout
@rendermode InteractiveServer

@using System.Globalization
@using System.IO
@using System.Linq
@using BookiwayApp.Services

@inject PdfDecomposerService PdfDecomposer
@inject IJSRuntime JS
@inject GeminiTranslationService Translator

<PageTitle>Bookiway</PageTitle>

<div class="translation-shell">
    <div class="hero">
        <span class="hero-eyebrow">Интерактивная мастерская</span>
        <span class="hero-brand">Bookiway</span>
        <p class="hero-subtitle">Минималистичный перевод PDF в HTML. Все параметры сохраняются в cookies и возвращаются при следующем запуске.</p>
    </div>

    <div class="workflow-grid">
        <section class="panel panel-upload">
            <header class="panel-header">
                <p class="panel-step">Шаг 1</p>
                <div>
                    <h2>Подготовка PDF</h2>
                    <p>Загрузите документ и выберите папку, куда сохранить изображения.</p>
                </div>
            </header>

            <div class="panel-block">
                <p class="field-label">PDF-файл</p>
                <label class="file-picker" for="pdfUpload">
                    <span class="file-picker-icon" aria-hidden="true">PDF</span>
                    <span class="file-picker-text">@(_fileName is null ? "Выберите PDF" : _fileName)</span>
                    <InputFile id="pdfUpload" OnChange="HandleFileSelected" accept="application/pdf" />
                </label>
                <p class="muted-text">До 10 МБ. Название и путь сохраняются локально.</p>
                @if (!string.IsNullOrWhiteSpace(_lastPdfName) && _selectedFile is null)
                {
                    <p class="muted-link" aria-live="polite">Ранее выбран: @_lastPdfName</p>
                }
            </div>

            <div class="panel-block">
                <p class="field-label">Папка для изображений</p>
                <div class="input-row">
                    <span class="input-chip">@(!string.IsNullOrWhiteSpace(TrimmedOutputDirectory) ? TrimmedOutputDirectory : "Не выбрано")</span>
                    <button type="button" class="ghost-button" @onclick="() => OpenDirectoryPicker(DirectoryTarget.Images)" disabled="@_isProcessing">Выбрать</button>
                </div>
                <p class="muted-text">Здесь появятся файлы page-XXXX.png. Путь восстанавливается из cookies.</p>
            </div>

            <div class="panel-block action-block">
                <div class="action-row">
                    <button class="primary-button" @onclick="StartDecompositionAsync" disabled="@IsDecomposeDisabled">
                        @if (_isProcessing)
                        {
                            <span class="spinner" aria-hidden="true"></span>
                        }
                        <span>@(_isProcessing ? "Разбираем..." : "Разложить PDF")</span>
                    </button>
                    <span class="hint">Кнопка активируется, когда найден PDF и папка назначения.</span>
                </div>

                @if (_isProcessing)
                {
                    <div class="progress" role="status" aria-live="polite">
                        <div class="progress-bar" style="width: @_progressPercent%;"></div>
                    </div>
                    <p class="progress-value">@_progressPercent%</p>
                }

                @if (!string.IsNullOrEmpty(_statusMessage))
                {
                    var statusClass = _isSuccess ? "status success" : "status error";
                    <p class="@statusClass">@_statusMessage</p>
                }
            </div>
        </section>

        <section class="panel panel-translate">
            <header class="panel-header">
                <p class="panel-step">Шаг 2</p>
                <div>
                    <h2>Перевод страниц</h2>
                    <p>Укажите диапазон и папку для HTML, чтобы получить статический сайт.</p>
                </div>
            </header>

            <div class="panel-block">
                <p class="field-label">Диапазон страниц</p>
                <div class="range-row">
                    <input type="number" min="1" max="@_totalPages" value="@_pageFrom" @oninput="OnPageFromChangedAsync" class="range-input" />
                    <span class="range-separator">–</span>
                    <input type="number" min="1" max="@_totalPages" value="@_pageTo" @oninput="OnPageToChangedAsync" class="range-input" />
                    <span class="range-total">@(_totalPages > 0 ? $"Всего: {_totalPages}" : "Пока нет страниц")</span>
                </div>
                @if (!string.IsNullOrEmpty(_pageRangeError))
                {
                    <p class="status error">@_pageRangeError</p>
                }
            </div>

            <div class="panel-block">
                <p class="field-label">Папка для HTML</p>
                <div class="input-row">
                    <span class="input-chip">@(!string.IsNullOrWhiteSpace(TrimmedTranslationDirectory) ? TrimmedTranslationDirectory : "Не выбрано")</span>
                    <button type="button" class="ghost-button" @onclick="() => OpenDirectoryPicker(DirectoryTarget.Html)" disabled="@_isTranslating">Выбрать</button>
                </div>
                <p class="muted-text">Путь нужен для статического хостинга. Мы его запомним.</p>
            </div>

            <div class="panel-block action-block">
                <div class="action-row">
                    <button class="primary-button" @onclick="StartTranslationAsync" disabled="@(!_isPageRangeValid || _totalPages == 0 || string.IsNullOrWhiteSpace(TrimmedTranslationDirectory) || _isTranslating)">
                        @if (_isTranslating)
                        {
                            <span class="spinner" aria-hidden="true"></span>
                        }
                        <span>@(_isTranslating ? "Переводим..." : "Перевести через Gemini")</span>
                    </button>
                    <span class="hint">Доступно после разложения PDF.</span>
                </div>

                @if (_isTranslating)
                {
                    <div class="progress" role="status" aria-live="polite">
                        <div class="progress-bar" style="width: @_translateProgress%;"></div>
                    </div>
                    <p class="progress-value">@_translateProgress%</p>
                }

                @if (!string.IsNullOrEmpty(_translateStatus))
                {
                    var tClass = _translateSuccess ? "status success" : "status error";
                    <p class="@tClass">@_translateStatus</p>
                }
            </div>
        </section>

        <section class="panel panel-prompt">
            <header class="panel-header">
                <p class="panel-step">Шаг 3</p>
                <div>
                    <h2>Промпт для Gemini</h2>
                    <p>Опишите стиль и нюансы перевода. Этот текст уходит в API вместе с изображением страницы.</p>
                </div>
            </header>

            <div class="panel-block">
                <p class="field-label">Текст инструкции</p>
                <textarea class="prompt-input" @oninput="OnPromptChanged" placeholder="Опишите, как нужно переводить текст">@_promptText</textarea>
                <div class="prompt-meta">
                    <span>Символов: @(_promptText?.Length ?? 0)</span>
                    <button type="button" class="ghost-button" @onclick="ResetPromptToDefault" disabled="@_isTranslating">Вернуть шаблон</button>
                </div>
                <p class="muted-text">Промпт автоматически сохраняется в cookies и применяется для всех страниц.</p>
            </div>
        </section>
    </div>
</div>
@if (_isDirectoryPickerOpen)
    {
        <div class="directory-modal" role="dialog" aria-modal="true">
            <div class="directory-modal-content">
                <div class="directory-modal-header">
                    <h3>Р’С‹Р±РѕСЂ РїР°РїРєРё</h3>
                    <p class="directory-modal-path" title="@_directoryBrowserPath">@_directoryBrowserPath</p>
                </div>

                @if (!string.IsNullOrEmpty(_directoryBrowserError))
                {
                    <p class="status error">@_directoryBrowserError</p>
                }

                <div class="directory-browser">
                    <div class="directory-browser-actions">
                        <button type="button" class="ghost-button" @onclick="NavigateUp" disabled="@(!CanNavigateUp)">РќР°Р·Р°Рґ</button>
                        <button type="button" class="ghost-button" @onclick="RefreshCurrentDirectory">РћР±РЅРѕРІРёС‚СЊ</button>
                    </div>

                    <ul class="directory-list" role="listbox">
                        @if (_directoryEntries.Count == 0)
                        {
                            <li class="directory-empty">РџР°РїРѕРє РЅРµ РЅР°Р№РґРµРЅРѕ</li>
                        }
                        else
                        {
                            @foreach (var entry in _directoryEntries)
                            {
                                <li>
                                    <button type="button" class="directory-item" @onclick="() => NavigateToDirectory(entry.FullPath)">
                                        <span class="directory-item-icon" aria-hidden="true"></span>
                                        <span>@entry.Name</span>
                                    </button>
                                </li>
                            }
                        }
                    </ul>
                </div>

                <div class="directory-modal-footer">
                    <button type="button" class="primary-button" @onclick="ConfirmDirectorySelectionAsync">РСЃРїРѕР»СЊР·РѕРІР°С‚СЊ СЌС‚Сѓ РїР°РїРєСѓ</button>
                    <button type="button" class="ghost-button" @onclick="CloseDirectoryPicker">РћС‚РјРµРЅР°</button>
                </div>
            </div>
        </div>
    }

@code {
    private const long MaxFileSize = 10 * 1024 * 1024;
    private const string PdfNameCookie = "bw_last_pdf_name";
    private const string ImagesDirCookie = "bw_last_output_dir";
    private const string HtmlDirCookie = "bw_last_html_dir";
    private const string PageFromCookie = "bw_last_page_from";
    private const string PageToCookie = "bw_last_page_to";
    private const string PdfCacheCookie = "bw_last_pdf_cache";
    private const string PromptCookie = "bw_prompt_text";
    private static readonly string PdfCacheDirectory = Path.Combine(AppContext.BaseDirectory, "PdfCache");

    private IBrowserFile? _selectedFile;
    private string? _fileName;
    private string _outputDirectory = string.Empty;
    private string _translationOutputDirectory = string.Empty;
    private string? _cachedPdfPath;
    private string? _lastPdfName;
    private string _promptText = GeminiTranslationService.DefaultPrompt;
    private int _totalPages;
    private int _pageFrom = 1;
    private int _pageTo = 1;
    private bool _isPageRangeValid = true;
    private string? _pageRangeError;
    private bool _isProcessing;
    private bool _isTranslating;
    private int _translateProgress;
    private string? _translateStatus;
    private bool _translateSuccess;
    private int _progressPercent;
    private string? _statusMessage;
    private bool _isSuccess;
    private bool _isDirectoryPickerOpen;
    private string _directoryBrowserPath = string.Empty;
    private List<DirectoryEntry> _directoryEntries = new();
    private string? _directoryBrowserError;
    private DirectoryTarget _directoryTarget = DirectoryTarget.Images;

    private bool HasCachedPdf => _selectedFile is not null || !string.IsNullOrWhiteSpace(_cachedPdfPath);
    private bool IsDecomposeDisabled => !HasCachedPdf || string.IsNullOrWhiteSpace(TrimmedOutputDirectory) || _isProcessing;
    private bool CanNavigateUp => TryGetParentDirectory(_directoryBrowserPath) is not null;
    private string TrimmedOutputDirectory => _outputDirectory?.Trim() ?? string.Empty;
    private string TrimmedTranslationDirectory => _translationOutputDirectory?.Trim() ?? string.Empty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        Directory.CreateDirectory(PdfCacheDirectory);

        _lastPdfName = await GetCookieAsync(PdfNameCookie);
        var savedImagesDir = await GetCookieAsync(ImagesDirCookie);
        if (!string.IsNullOrWhiteSpace(savedImagesDir))
        {
            _outputDirectory = savedImagesDir!;
        }

        var savedHtmlDir = await GetCookieAsync(HtmlDirCookie);
        if (!string.IsNullOrWhiteSpace(savedHtmlDir))
        {
            _translationOutputDirectory = savedHtmlDir!;
        }

        var savedPrompt = await GetCookieAsync(PromptCookie);
        _promptText = string.IsNullOrWhiteSpace(savedPrompt)
            ? GeminiTranslationService.DefaultPrompt
            : savedPrompt!;

        var cachedPdfId = await GetCookieAsync(PdfCacheCookie);
        if (!string.IsNullOrWhiteSpace(cachedPdfId))
        {
            var potentialPath = Path.Combine(PdfCacheDirectory, cachedPdfId!);
            var exists = File.Exists(potentialPath);
            _cachedPdfPath = potentialPath;

            if (exists && !string.IsNullOrWhiteSpace(_lastPdfName))
            {
                _fileName = _lastPdfName;
            }
            else if (!exists && !string.IsNullOrWhiteSpace(_lastPdfName))
            {
                _statusMessage = $"Р¤Р°Р№Р» {_lastPdfName} РЅРµ РЅР°Р№РґРµРЅ РІ РєРµС€Рµ, Р·Р°РіСЂСѓР·РёС‚Рµ РµРіРѕ Р·Р°РЅРѕРІРѕ.";
                _isSuccess = false;
            }
        }

        var savedFrom = await GetCookieAsync(PageFromCookie);
        if (int.TryParse(savedFrom, NumberStyles.Integer, CultureInfo.InvariantCulture, out var fromValue) && fromValue > 0)
        {
            _pageFrom = fromValue;
        }

        var savedTo = await GetCookieAsync(PageToCookie);
        if (int.TryParse(savedTo, NumberStyles.Integer, CultureInfo.InvariantCulture, out var toValue) && toValue > 0)
        {
            _pageTo = toValue;
        }

        if (!string.IsNullOrWhiteSpace(TrimmedOutputDirectory))
        {
            await RecalculatePagesFromImagesFolderAsync();
        }
        else
        {
            ValidatePageRange();
            await PersistPageRangeAsync();
        }

        StateHasChanged();
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        _selectedFile = e.File;
        _fileName = e.File?.Name;
        _statusMessage = null;

        if (!string.IsNullOrWhiteSpace(_fileName))
        {
            await SaveCookieAsync(PdfNameCookie, _fileName);
            _lastPdfName = _fileName;
        }

        try
        {
            await CacheSelectedFileAsync();
        }
        catch (Exception ex)
        {
            _cachedPdfPath = null;
            _statusMessage = $"РќРµ СѓРґР°Р»РѕСЃСЊ СЃРѕС…СЂР°РЅРёС‚СЊ PDF: {ex.Message}";
        }
    }

    private enum DirectoryTarget
    {
        Images,
        Html
    }

    private async Task CacheSelectedFileAsync()
    {
        if (_selectedFile is null)
        {
            return;
        }

        Directory.CreateDirectory(PdfCacheDirectory);

        if (!string.IsNullOrWhiteSpace(_cachedPdfPath) && File.Exists(_cachedPdfPath))
        {
            TryDeleteFile(_cachedPdfPath);
        }

        var extension = Path.GetExtension(_selectedFile.Name);
        var safeExtension = string.IsNullOrWhiteSpace(extension) ? ".pdf" : extension;
        var cacheFileName = $"{Guid.NewGuid():N}{safeExtension}";
        var cacheFullPath = Path.Combine(PdfCacheDirectory, cacheFileName);

        await using var targetStream = File.Create(cacheFullPath);
        await using var sourceStream = _selectedFile.OpenReadStream(MaxFileSize);
        await sourceStream.CopyToAsync(targetStream);

        _cachedPdfPath = cacheFullPath;
        await SaveCookieAsync(PdfCacheCookie, cacheFileName);

        _selectedFile = null;
    }

    private async Task<Stream?> GetPdfStreamAsync()
    {
        if (!string.IsNullOrWhiteSpace(_cachedPdfPath) && File.Exists(_cachedPdfPath))
        {
            return File.OpenRead(_cachedPdfPath);
        }

        if (_selectedFile is not null)
        {
            await CacheSelectedFileAsync();
            if (!string.IsNullOrWhiteSpace(_cachedPdfPath) && File.Exists(_cachedPdfPath))
            {
                return File.OpenRead(_cachedPdfPath);
            }
        }

        return null;
    }

    private void OpenDirectoryPicker(DirectoryTarget target)
    {
        _directoryTarget = target;
        var current = target == DirectoryTarget.Images ? TrimmedOutputDirectory : TrimmedTranslationDirectory;
        var initialPath = string.IsNullOrWhiteSpace(current) ? GetDefaultDirectory() : current;

        _directoryBrowserError = null;

        if (!TryLoadDirectory(initialPath))
        {
            TryLoadDirectory(GetDefaultDirectory());
        }

        _isDirectoryPickerOpen = true;
    }

    private void CloseDirectoryPicker()
    {
        _isDirectoryPickerOpen = false;
    }

    private async Task ConfirmDirectorySelectionAsync()
    {
        if (!string.IsNullOrWhiteSpace(_directoryBrowserPath))
        {
            if (_directoryTarget == DirectoryTarget.Images)
            {
                _outputDirectory = _directoryBrowserPath;
                await SaveCookieAsync(ImagesDirCookie, _outputDirectory);
                await RecalculatePagesFromImagesFolderAsync();
            }
            else
            {
                _translationOutputDirectory = _directoryBrowserPath;
                await SaveCookieAsync(HtmlDirCookie, _translationOutputDirectory);
            }
        }

        _isDirectoryPickerOpen = false;
    }

    private void NavigateToDirectory(string path)
    {
        TryLoadDirectory(path);
    }

    private void NavigateUp()
    {
        var parent = TryGetParentDirectory(_directoryBrowserPath);
        if (parent is not null)
        {
            TryLoadDirectory(parent.FullName);
        }
    }

    private void RefreshCurrentDirectory()
    {
        TryLoadDirectory(_directoryBrowserPath);
    }

    private async Task StartDecompositionAsync()
    {
        if (!HasCachedPdf)
        {
            _statusMessage = "Р’С‹Р±РµСЂРёС‚Рµ PDF-С„Р°Р№Р» РёР»Рё Р·Р°РіСЂСѓР·РёС‚Рµ РµРіРѕ Р·Р°РЅРѕРІРѕ.";
            _isSuccess = false;
            return;
        }

        if (string.IsNullOrWhiteSpace(TrimmedOutputDirectory))
        {
            _statusMessage = "РЈРєР°Р¶РёС‚Рµ РїР°РїРєСѓ, РєСѓРґР° СЃРѕС…СЂР°РЅСЏС‚СЊ РёР·РѕР±СЂР°Р¶РµРЅРёСЏ.";
            _isSuccess = false;
            return;
        }

        _isProcessing = true;
        _statusMessage = null;
        _isSuccess = false;
        _progressPercent = 0;
        _totalPages = 0;

        var progress = new Progress<double>(value =>
        {
            _progressPercent = (int)Math.Clamp(Math.Round(value * 100, MidpointRounding.AwayFromZero), 0, 100);
            InvokeAsync(StateHasChanged);
        });

        try
        {
            await using var stream = await GetPdfStreamAsync();
            if (stream is null)
            {
                _statusMessage = "РќРµ СѓРґР°Р»РѕСЃСЊ РїСЂРѕС‡РёС‚Р°С‚СЊ PDF РёР· РєРµС€Р°. Р—Р°РіСЂСѓР·РёС‚Рµ С„Р°Р№Р» РµС‰С‘ СЂР°Р·.";
                _isSuccess = false;
                return;
            }

            var outputDirectory = TrimmedOutputDirectory;
            var result = await PdfDecomposer.DecomposeAsync(stream, outputDirectory, progress);

            _isSuccess = true;
            _statusMessage = result.PageCount == 0
                ? "PDF РЅРµ СЃРѕРґРµСЂР¶РёС‚ СЃС‚СЂР°РЅРёС† РёР»Рё РµРіРѕ РЅРµ СѓРґР°Р»РѕСЃСЊ СЂР°Р·РѕР±СЂР°С‚СЊ."
                : $"Р“РѕС‚РѕРІРѕ: СЃРѕС…СЂР°РЅРµРЅРѕ {result.PageCount} СЃС‚СЂР°РЅРёС† РІ '{outputDirectory}'.";
            _progressPercent = 100;

            _totalPages = result.PageCount;
            _pageFrom = _totalPages > 0 ? 1 : 0;
            _pageTo = _totalPages;
            ValidatePageRange();
            await PersistPageRangeAsync();
        }
        catch (Exception ex)
        {
            _isSuccess = false;
            _statusMessage = $"РћС€РёР±РєР° РїСЂРё СЂР°Р·Р»РѕР¶РµРЅРёРё PDF: {ex.Message}";
        }
        finally
        {
            _isProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnPageFromChangedAsync(ChangeEventArgs e)
    {
        if (int.TryParse(Convert.ToString(e.Value, CultureInfo.InvariantCulture), NumberStyles.Integer, CultureInfo.InvariantCulture, out var value))
        {
            _pageFrom = value;
            ValidatePageRange();
            await PersistPageRangeAsync();
        }
    }

    private async Task OnPageToChangedAsync(ChangeEventArgs e)
    {
        if (int.TryParse(Convert.ToString(e.Value, CultureInfo.InvariantCulture), NumberStyles.Integer, CultureInfo.InvariantCulture, out var value))
        {
            _pageTo = value;
            ValidatePageRange();
            await PersistPageRangeAsync();
        }
    }

    private async Task OnPromptChanged(ChangeEventArgs e)
    {
        _promptText = e.Value?.ToString() ?? string.Empty;
        await SaveCookieAsync(PromptCookie, _promptText);
    }

    private async Task ResetPromptToDefault()
    {
        _promptText = GeminiTranslationService.DefaultPrompt;
        await SaveCookieAsync(PromptCookie, _promptText);
    }

    private void ValidatePageRange()
    {
        _isPageRangeValid = _totalPages > 0 && _pageFrom >= 1 && _pageTo >= 1 && _pageFrom <= _pageTo && _pageTo <= _totalPages;
        _pageRangeError = _isPageRangeValid ? null : "РџСЂРѕРІРµСЂСЊС‚Рµ РґРёР°РїР°Р·РѕРЅ СЃС‚СЂР°РЅРёС†. РћРЅ РЅРµ РґРѕР»Р¶РµРЅ РІС‹С…РѕРґРёС‚СЊ Р·Р° РіСЂР°РЅРёС†С‹ РЅР°Р№РґРµРЅРЅС‹С… PNG.";
    }

    private async Task RecalculatePagesFromImagesFolderAsync()
    {
        try
        {
            if (!string.IsNullOrWhiteSpace(TrimmedOutputDirectory) && Directory.Exists(TrimmedOutputDirectory))
            {
                var files = Directory.GetFiles(TrimmedOutputDirectory, "page-*.png");
                _totalPages = files.Length;
                _pageFrom = _totalPages > 0 ? Math.Clamp(_pageFrom <= 0 ? 1 : _pageFrom, 1, _totalPages) : 0;
                _pageTo = _totalPages > 0 ? Math.Clamp(_pageTo <= 0 ? _totalPages : _pageTo, 1, _totalPages) : 0;
                ValidatePageRange();
            }
            else
            {
                _totalPages = 0;
                ValidatePageRange();
            }
        }
        catch
        {
            _totalPages = 0;
            ValidatePageRange();
        }

        await PersistPageRangeAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task StartTranslationAsync()
    {
        if (!_isPageRangeValid || _totalPages == 0)
        {
            _translateSuccess = false;
            _translateStatus = "РџСЂРѕРІРµСЂСЊС‚Рµ, С‡С‚Рѕ PDF СЂР°Р·Р»РѕР¶РµРЅ Рё РґРёР°РїР°Р·РѕРЅ СЃС‚СЂР°РЅРёС† СѓРєР°Р·Р°РЅ РєРѕСЂСЂРµРєС‚РЅРѕ.";
            return;
        }

        var sourceDir = TrimmedOutputDirectory;
        var destinationDir = TrimmedTranslationDirectory;

        if (string.IsNullOrWhiteSpace(sourceDir) || string.IsNullOrWhiteSpace(destinationDir))
        {
            _translateSuccess = false;
            _translateStatus = "РќСѓР¶РЅС‹ РїР°РїРєР° СЃ РёР·РѕР±СЂР°Р¶РµРЅРёСЏРјРё Рё РїР°РїРєР° РґР»СЏ HTML-СЂРµР·СѓР»СЊС‚Р°С‚Р°.";
            return;
        }

        _isTranslating = true;
        _translateProgress = 0;
        _translateStatus = null;
        _translateSuccess = false;

        var progress = new Progress<double>(value =>
        {
            _translateProgress = (int)Math.Clamp(Math.Round(value * 100, MidpointRounding.AwayFromZero), 0, 100);
            InvokeAsync(StateHasChanged);
        });

        try
        {
            var prompt = string.IsNullOrWhiteSpace(_promptText)
                ? GeminiTranslationService.DefaultPrompt
                : _promptText;
            var count = await Translator.TranslateRangeAsync(sourceDir, _pageFrom, _pageTo, destinationDir, prompt, progress);
            _translateSuccess = count > 0;
            _translateStatus = count == 0
                ? "РќРµ РЅР°Р№РґРµРЅРѕ СЃС‚СЂР°РЅРёС† РІ СѓРєР°Р·Р°РЅРЅРѕРј РґРёР°РїР°Р·РѕРЅРµ."
                : $"Р“РѕС‚РѕРІРѕ: СЃРѕР·РґР°РЅРѕ {count} HTML-С„Р°Р№Р»РѕРІ РІ '{destinationDir}'.";
        }
        catch (Exception ex)
        {
            _translateSuccess = false;
            _translateStatus = $"РћС€РёР±РєР° РїСЂРё РїРµСЂРµРІРѕРґРµ: {ex.Message}";
        }
        finally
        {
            _isTranslating = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private bool TryLoadDirectory(string directory)
    {
        try
        {
            var fullPath = Path.GetFullPath(directory);
            if (!Directory.Exists(fullPath))
            {
                _directoryBrowserError = $"РљР°С‚Р°Р»РѕРі '{directory}' РЅРµ РЅР°Р№РґРµРЅ.";
                _directoryEntries = new List<DirectoryEntry>();
                return false;
            }

            _directoryBrowserPath = fullPath;
            _directoryEntries = Directory.GetDirectories(fullPath)
                .OrderBy(dir => dir, StringComparer.OrdinalIgnoreCase)
                .Select(dir => new DirectoryEntry(GetDirectoryDisplayName(dir), dir))
                .ToList();
            _directoryBrowserError = null;
            return true;
        }
        catch (Exception ex)
        {
            _directoryBrowserError = $"РћС€РёР±РєР° РїСЂРё С‡С‚РµРЅРёРё РєР°С‚Р°Р»РѕРіР°: {ex.Message}";
            _directoryEntries = new List<DirectoryEntry>();
            return false;
        }
    }

    private static string GetDirectoryDisplayName(string path)
    {
        var name = Path.GetFileName(path);
        if (string.IsNullOrEmpty(name))
        {
            name = new DirectoryInfo(path).Name;
        }

        return string.IsNullOrEmpty(name) ? path : name;
    }

    private static DirectoryInfo? TryGetParentDirectory(string? path)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return null;
        }

        try
        {
            return Directory.GetParent(path);
        }
        catch
        {
            return null;
        }
    }

    private static string GetDefaultDirectory()
    {
        var candidates = new[]
        {
            Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
            Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
            Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
            Environment.CurrentDirectory
        };

        foreach (var candidate in candidates)
        {
            if (!string.IsNullOrWhiteSpace(candidate) && Directory.Exists(candidate))
            {
                return candidate;
            }
        }

        return Environment.CurrentDirectory;
    }

    private static void TryDeleteFile(string path)
    {
        try
        {
            File.Delete(path);
        }
        catch
        {
        }
    }

    private async Task SaveCookieAsync(string key, string value)
    {
        await JS.InvokeAsync<bool>("cookies.set", key, value, 365);
    }

    private async Task<string?> GetCookieAsync(string key)
    {
        return await JS.InvokeAsync<string?>("cookies.get", key);
    }

    private async Task PersistPageRangeAsync()
    {
        if (_pageFrom > 0)
        {
            await SaveCookieAsync(PageFromCookie, _pageFrom.ToString(CultureInfo.InvariantCulture));
        }

        if (_pageTo > 0)
        {
            await SaveCookieAsync(PageToCookie, _pageTo.ToString(CultureInfo.InvariantCulture));
        }
    }

    private sealed record DirectoryEntry(string Name, string FullPath);
}



